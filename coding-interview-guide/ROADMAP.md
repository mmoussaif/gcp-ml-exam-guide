# Coding Interview Roadmap

A clear path from beginner to interview-ready, organized by learning order and difficulty.

## üéØ Overview

This roadmap follows a progressive learning approach: each topic builds on previous ones. Don't skip ahead‚Äîmaster the fundamentals first.

---

## üìö Prerequisites

Before starting, you should:

- Know basic programming (loops, conditionals, functions)
- Be comfortable in at least one language (Python, Java, JavaScript, C++, C#)
- Understand basic math (addition, multiplication, simple formulas)

---

## üó∫Ô∏è Learning Path

### **Phase 1: Foundations** (Week 1-2)

_Master the basics before moving forward_

#### 1. RAM & Memory Basics

- **Why first?** Understanding memory is the foundation for everything else
- **Key concept:** How data is stored in contiguous memory addresses
- **Time:** 1-2 hours
- **Files:** `docs/main.md` (section 1), `code/ram_demo.py`

#### 2. Static Arrays

- **Why next?** Arrays are the most fundamental data structure
- **Key concepts:** Index access, insertion, deletion, shifting
- **Time complexity focus:** O(1) access vs O(n) insertion/deletion
- **Time:** 2-3 hours
- **Files:** `docs/main.md` (section 2), `code/static_array_ops.py`
- **Practice:** Remove Duplicates, Remove Element

#### 3. Dynamic Arrays

- **Why next?** Most languages use dynamic arrays by default
- **Key concepts:** Resizing, amortized time complexity
- **Time:** 1-2 hours
- **Files:** `docs/main.md` (section 3), `code/dynamic_array.py`
- **Practice:** Concatenation of Array

---

### **Phase 2: Linear Data Structures** (Week 2-3)

_Learn structures that process data in order_

#### 4. Stacks

- **Why now?** Simple LIFO structure, builds on arrays
- **Key concepts:** Push, pop, peek, LIFO behavior
- **Time:** 2-3 hours
- **Files:** `docs/main.md` (section 4), `code/stack.py`
- **Practice:** Valid Parentheses, Min Stack

#### 5. Singly Linked Lists

- **Why now?** Introduces pointer-based structures
- **Key concepts:** Nodes, pointers, traversal, insertion/deletion
- **Time:** 3-4 hours
- **Files:** `docs/main.md` (section 5), `code/singly_linked_list.py`
- **Practice:** Reverse Linked List, Merge Two Sorted Lists

#### 6. Doubly Linked Lists

- **Why now?** Extension of singly linked lists
- **Key concepts:** Bidirectional traversal, prev pointers
- **Time:** 2-3 hours
- **Files:** `docs/main.md` (section 6), `code/doubly_linked_list.py`
- **Practice:** Design Linked List, Design Browser History

#### 7. Queues

- **Why now?** FIFO structure, complements stacks
- **Key concepts:** Enqueue, dequeue, FIFO behavior
- **Time:** 2-3 hours
- **Files:** `docs/main.md` (section 7), `code/queue.py`
- **Practice:** Number of Students Unable to Eat Lunch, Implement Stack Using Queues

---

### **Phase 3: Algorithms & Problem Solving** (Week 3-5)

_Learn how to solve problems efficiently_

#### 8. Recursion

- **Why now?** Essential for trees, backtracking, and many algorithms
- **Key concepts:** Base cases, recursive cases, call stack
- **Time:** 4-5 hours
- **Practice:** Fibonacci, Factorial, Reverse String

#### 9. Sorting Algorithms

- **Why now?** Fundamental algorithmic technique
- **Key concepts:** Comparison vs non-comparison sorts, stability
- **Algorithms:** Bubble, Selection, Insertion, Merge, Quick, Heap
- **Time:** 6-8 hours
- **Practice:** Sort an Array, Merge Sorted Arrays

#### 10. Binary Search

- **Why now?** Powerful search technique, requires sorted data
- **Key concepts:** Divide and conquer, search space reduction
- **Time:** 3-4 hours
- **Practice:** Binary Search, Search Insert Position, Find Peak Element

---

### **Phase 4: Trees** (Week 5-7)

_Hierarchical data structures_

#### 11. Binary Trees

- **Why now?** Foundation for all tree problems
- **Key concepts:** Nodes, children, traversal (DFS, BFS)
- **Time:** 4-5 hours
- **Practice:** Maximum Depth, Same Tree, Invert Binary Tree

#### 12. Binary Search Trees (BST)

- **Why now?** Ordered trees with efficient search
- **Key concepts:** BST property, insertion, deletion, search
- **Time:** 4-5 hours
- **Practice:** Validate BST, Search in BST, Insert into BST

#### 13. Tree Traversals

- **Why now?** Essential for tree problems
- **Key concepts:** Pre-order, In-order, Post-order, Level-order
- **Time:** 3-4 hours
- **Practice:** Binary Tree Inorder Traversal, Level Order Traversal

---

### **Phase 5: Advanced Topics** (Week 7-10)

_Complex problem-solving techniques_

#### 14. Backtracking

- **Why now?** Powerful technique for constraint satisfaction
- **Key concepts:** Try, explore, undo (backtrack)
- **Time:** 5-6 hours
- **Practice:** Subsets, Permutations, Combination Sum

#### 15. Heap / Priority Queue

- **Why now?** Efficient access to min/max elements
- **Key concepts:** Min-heap, max-heap, heapify
- **Time:** 4-5 hours
- **Practice:** Kth Largest Element, Merge K Sorted Lists

#### 16. Hashing

- **Why now?** O(1) average-time lookups
- **Key concepts:** Hash functions, collisions, hash maps/sets
- **Time:** 3-4 hours
- **Practice:** Two Sum, Group Anagrams, Longest Consecutive Sequence

#### 17. Graphs

- **Why now?** Model relationships and networks
- **Key concepts:** Nodes, edges, adjacency lists/matrices, traversal
- **Algorithms:** DFS, BFS, shortest paths
- **Time:** 6-8 hours
- **Practice:** Number of Islands, Clone Graph, Course Schedule

#### 18. Dynamic Programming

- **Why now?** Optimize recursive solutions
- **Key concepts:** Memoization, tabulation, overlapping subproblems
- **Time:** 8-10 hours
- **Practice:** Climbing Stairs, House Robber, Longest Common Subsequence

#### 19. Bit Manipulation

- **Why now?** Advanced optimization technique
- **Key concepts:** Bitwise operations, masks, tricks
- **Time:** 3-4 hours
- **Practice:** Number of 1 Bits, Single Number, Power of Two

---

## üìä Progress Tracking

### Beginner (0-30% complete)

- ‚úÖ Understand RAM and memory
- ‚úÖ Master arrays (static and dynamic)
- ‚úÖ Understand stacks and queues
- ‚úÖ Basic linked list operations

### Intermediate (30-60% complete)

- ‚úÖ Comfortable with recursion
- ‚úÖ Can implement sorting algorithms
- ‚úÖ Understand binary search
- ‚úÖ Can traverse trees
- ‚úÖ Basic backtracking

### Advanced (60-90% complete)

- ‚úÖ Can solve tree problems confidently
- ‚úÖ Understand graph algorithms
- ‚úÖ Can identify DP problems
- ‚úÖ Comfortable with hashing
- ‚úÖ Can optimize with bit manipulation

### Interview Ready (90-100% complete)

- ‚úÖ Can explain time/space complexity
- ‚úÖ Can discuss trade-offs
- ‚úÖ Can code solutions under time pressure
- ‚úÖ Can handle follow-up questions
- ‚úÖ Comfortable with system design basics

---

## üéØ Study Strategy

### Daily Routine (2-3 hours)

1. **Review** (15 min): Read one section from `docs/main.md`
2. **Code** (30 min): Study the code in `code/` with comments
3. **Practice** (60-90 min): Solve 1-2 problems on LeetCode
4. **Review** (15 min): Review solution, understand time/space complexity

### Weekly Goals

- Complete 1-2 topics from the roadmap
- Solve 10-15 practice problems
- Review mistakes and understand why solutions work

### Before Interviews

- Complete all topics in roadmap
- Solve 100+ problems total
- Mock interviews with peers
- Review common patterns

---

## üîó Resources

### Primary Resources

- **This repo:** `docs/main.md` for concepts, `code/` for implementations
- **Curated problem lists:** Practice problems matching this roadmap
- **LeetCode:** Practice problems

### Additional Resources

- **Big O Cheat Sheet:** Understand time complexities
- **Visualizations:** Visualgo.net for algorithm animations
- **Interview Prep:** System Design Primer (for system design questions)

---

## ‚ö†Ô∏è Common Mistakes to Avoid

1. **Skipping fundamentals:** Don't jump to advanced topics without mastering basics
2. **Memorizing solutions:** Focus on understanding patterns, not memorizing code
3. **Not practicing:** Reading isn't enough‚Äîyou must code solutions
4. **Ignoring complexity:** Always analyze time and space complexity
5. **Giving up too early:** Struggle is part of learning‚Äîpersist through difficult problems

---

## üéì Interview Tips

### During the Interview

1. **Clarify:** Ask questions about edge cases and constraints
2. **Think aloud:** Explain your thought process
3. **Start simple:** Begin with brute force, then optimize
4. **Code cleanly:** Write readable, well-structured code
5. **Test:** Walk through examples to verify your solution

### What to Say

- "Let me think about the time and space complexity..."
- "I'll start with a brute force approach, then optimize..."
- "The trade-off here is between time and space..."
- "Let me trace through an example to verify..."

---

## üìÖ Timeline Examples

### Fast Track (2-3 months, 3-4 hours/day)

- Week 1-2: Phases 1-2 (Foundations + Linear Structures)
- Week 3-4: Phase 3 (Algorithms)
- Week 5-6: Phase 4 (Trees)
- Week 7-8: Phase 5 (Advanced Topics)
- Week 9-12: Practice and mock interviews

### Standard Track (4-6 months, 2-3 hours/day)

- Month 1: Phases 1-2
- Month 2: Phase 3
- Month 3: Phase 4
- Month 4-5: Phase 5
- Month 6: Intensive practice and mock interviews

### Part-Time Track (6-12 months, 1-2 hours/day)

- Follow the same phases but at a slower pace
- Focus on understanding deeply rather than speed
- More time for practice between topics

---

## ‚úÖ Next Steps

1. **Start with Phase 1:** Read RAM section in `docs/main.md`
2. **Set a schedule:** Choose your track and commit to daily practice
3. **Track progress:** Check off topics as you complete them
4. **Join a community:** Find study partners or join coding interview groups
5. **Stay consistent:** Small daily progress beats occasional cramming

**Remember:** The goal isn't to rush through topics, but to deeply understand each concept. Quality over quantity!
